\documentclass{jcgt}

\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\usepackage{siunitx}
\usepackage{csquotes}
\usepackage{url}
\usepackage{subcaption}
\usepackage{xcolor}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{xfrac}
\usepackage{comment}
\usepackage{natbib}


\setciteauthor{Matthias Raab and Laurent Belcour and Frankie Liu and Jamie Portsmouth}
\setcitetitle{The Minimal Retroreflective Microfacet Model (MRMM)}
%\setheadtitle{Abbreviated title, only if full title won't fit in page headers}

% Mark submissions with the date of submission using the following line:
\submitted{\today}

% Once an article is accepted accepted, switch to the following line and comment the preceding one. The editor will supply the argument values.
\accepted{yyyy-mm-dd}{yyyy-mm-dd}{yyyy-mm-dd}{Editor Name}{volume}{issue}{1}{6}{yyyy}
\seturl{http://jcgt.org/published/vol/issue/num/}

\newcommand{\vecv}{\mathbf{v}}
\newcommand{\vecvv}{\mathbf{v'}}
\newcommand{\vecl}{\mathbf{l}}
\newcommand{\vecll}{\mathbf{l'}}
\newcommand{\vecn}{\mathbf{n}}
\newcommand{\vecm}{\mathbf{m}}
\newcommand{\vech}{\mathbf{h}}
\newcommand{\vecb}{\mathbf{b}}
\newcommand{\vdot}[2]{\left\langle #1, #2 \right\rangle}

\newcommand{\todo}[1]{{\color{red}\textbf{[TODO:} #1\textbf{]}}}
\newcommand{\laurent}[1]{{\color{blue}\textbf{[Laurent:} #1\textbf{]}}}

\includecomment{introduction}
\includecomment{existing-models}
\includecomment{eon}
\includecomment{eon-sampling}
\includecomment{conclusion}

\urlstyle{same}

\captionsetup[table]{skip=10pt}

\lstdefinelanguage{GLSL}%
{%
	morekeywords={%
	% HLSL constants
		false,FALSE,NULL,true,TRUE,%
	% GLSL predefinde macro constant
		__LINE__,__FILE__,__VERSION__,GL_core_profile,GL_es_profile,GL_compatibility_profile,%
	% GLSL precision modifier
		precision,highp,mediump,lowp,%
	% GLSL types
		void,bool,int,uint,float,double,vec2,vec3,vec4,dvec2,dvec3,dvec4,bvec2,bvec3,bvec4,ivec2,ivec3,ivec4,uvec2,uvec3,uvec4,mat2,mat3,mat4,mat2x2,mat2x3,mat2x4,mat3x2,mat3x3,mat3x4,mat4x2,mat4x3,mat4x4,dmat2,dmat3,dmat4,dmat2x2,dmat2x3,dmat2x4,dmat3x2,dmat3x3,dmat3x4,dmat4x2,dmat4x3,dmat4x4,sampler1D,sampler2D,sampler3D,image1D,image2D,image3D,samplerCube,imageCube,sampler2DRect,image2DRect,sampler1DArray,sampler2DArray,image1DArray,image2DArray,samplerBuffer,imageBuffer,sampler2DMS,image2DMS,sampler2DMSArray,image2DMSArray,samplerCubeArray,imageCubeArray,sampler1DShadow,sampler2DShadow,sampler2DRectShadow,sampler1DArrayShadow,sampler2DArrayShadow,samplerCubeShadow,samplerCubeArrayShadow,isampler1D,isampler2D,isampler3D,iimage1D,iimage2D,iimage3D,isamplerCube,iimageCube,isampler2DRect,iimage2DRect,isampler1DArray,isampler2DArray,iimage1DArray,iimage2DArray,isamplerBuffer,iimageBuffer,isampler2DMS,iimage2DMS,isampler2DMSArray,iimage2DMSArray,isamplerCubeArray,iimageCubeArray,atomic_uint,usampler1D,usampler2D,usampler3D,uimage1D,uimage2D,uimage3D,usamplerCube,uimageCube,usampler2DRect,uimage2DRect,usampler1DArray,usampler2DArray,uimage1DArray,uimage2DArray,usamplerBuffer,uimageBuffer,usampler2DMS,uimage2DMS,usampler2DMSArray,uimage2DMSArray,usamplerCubeArray,uimageCubeArray,struct,%
	% GLSL support variables
		gl_BackColor,gl_BackLightModelProduct,gl_BackLightProduct,gl_BackMaterial,gl_BackSecondaryColor,gl_ClipDistance,gl_ClipPlane,gl_ClipVertex,gl_Color,gl_DepthRange,gl_DepthRangeParameters,gl_EyePlaneQ,gl_EyePlaneR,gl_EyePlaneS,gl_EyePlaneT,gl_Fog,gl_FogCoord,gl_FogFragCoord,gl_FogParameters,gl_FragColor,gl_FragCoord,gl_FragData,gl_FragDepth,gl_FrontColor,gl_FrontFacing,gl_FrontLightModelProduct,gl_FrontLightProduct,gl_FrontMaterial,gl_FrontSecondaryColor,gl_InstanceID,gl_Layer,gl_LightModel,gl_LightModelParameters,gl_LightModelProducts,gl_LightProducts,gl_LightSource,gl_LightSourceParameters,gl_MaterialParameters,gl_ModelViewMatrix,gl_ModelViewMatrixInverse,gl_ModelViewMatrixInverseTranspose,gl_ModelViewMatrixTranspose,gl_ModelViewProjectionMatrix,gl_ModelViewProjectionMatrixInverse,gl_ModelViewProjectionMatrixInverseTranspose,gl_ModelViewProjectionMatrixTranspose,gl_MultiTexCoord0,gl_MultiTexCoord1,gl_MultiTexCoord2,gl_MultiTexCoord3,gl_MultiTexCoord4,gl_MultiTexCoord5,gl_MultiTexCoord6,gl_MultiTexCoord7,gl_Normal,gl_NormalMatrix,gl_NormalScale,gl_ObjectPlaneQ,gl_ObjectPlaneR,gl_ObjectPlaneS,gl_ObjectPlaneT,gl_Point,gl_PointCoord,gl_PointParameters,gl_PointSize,gl_Position,gl_PrimitiveIDIn,gl_ProjectionMatrix,gl_ProjectionMatrixInverse,gl_ProjectionMatrixInverseTranspose,gl_ProjectionMatrixTranspose,gl_SecondaryColor,gl_TexCoord,gl_TextureEnvColor,gl_TextureMatrix,gl_TextureMatrixInverse,gl_TextureMatrixInverseTranspose,gl_TextureMatrixTranspose,gl_Vertex,gl_VertexID,%
	% GLSL support constants
		gl_MaxClipPlanes,gl_MaxCombinedTextureImageUnits,gl_MaxDrawBuffers,gl_MaxFragmentUniformComponents,gl_MaxLights,gl_MaxTextureCoords,gl_MaxTextureImageUnits,gl_MaxTextureUnits,gl_MaxVaryingFloats,gl_MaxVertexAttribs,gl_MaxVertexTextureImageUnits,gl_MaxVertexUniformComponents,%
	% GLSL support functions
		abs,acos,all,any,asin,atan,ceil,clamp,cos,cross,degrees,dFdx,dFdy,distance,dot,equal,exp,exp2,faceforward,floor,fract,ftransform,fwidth,greaterThan,greaterThanEqual,inversesqrt,length,lessThan,lessThanEqual,log,log2,matrixCompMult,max,min,mix,mod,noise1,noise2,noise3,noise4,normalize,not,notEqual,outerProduct,pow,radians,reflect,refract,shadow1D,shadow1DLod,shadow1DProj,shadow1DProjLod,shadow2D,shadow2DLod,shadow2DProj,shadow2DProjLod,sign,sin,smoothstep,sqrt,step,tan,texture1D,texture1DLod,texture1DProj,texture1DProjLod,texture2D,texture2DLod,texture2DProj,texture2DProjLod,texture3D,texture3DLod,texture3DProj,texture3DProjLod,textureCube,textureCubeLod,transpose,%
	% GLSL struct member -> FixMe: Should have dot(.) as delimiter
		rgb
	},
	sensitive=true,%
	morecomment=[s]{/*}{*/},%
	morecomment=[l]//,%
	morestring=[b]",%
	morestring=[b]',%
	moredelim=*[directive]\#,%
	% keyword.control.hlsl
	moredirectives={define,defined,elif,else,if,ifdef,endif,line,error,ifndef,include,pragma,undef,warning,extension,version},%
  % keyword highlighting%
  classoffset=1, % starting new class
  keywords={retroGGX, break,case,continue,default,discard,do,else,for,if,return,switch,while,define},%
  keywordstyle=\color{codeblue}\bfseries,%
  classoffset=0%
  }[keywords,comments,strings,directives]%

\definecolor{backcolour}{rgb}{1, 1, 1}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{codeblue}{rgb}{0,0.3,0.6}

\lstset{language=GLSL,
        linewidth=1.0\linewidth,
        backgroundcolor=\color{backcolour},
        commentstyle=\color{codegreen},
        keywordstyle=\color{magenta},
        numberstyle=\tiny\color{codegray},
        stringstyle=\color{codepurple},
        basicstyle=\ttfamily\scriptsize,
        breakatwhitespace=false,
        breaklines=true,
        keepspaces=true,
        numbers=none,
        numbersep=5pt,
        showspaces=false,
        showstringspaces=false,
        showtabs=false,
        escapeinside={<@}{@>},
        tabsize=2,
        texcl=false,
        frameround=fttt
        }


\begin{document}


\title{The Minimal Retroreflective Microfacet Model}

\author{Matthias Raab\\NVIDIA
        \and Laurent Belcour\\Intel
        \and Frankie Liu\\NVIDIA
        \and Jamie Portsmouth\\Autodesk
       }

\teaser{
  \vspace*{-0.5cm}
  \centering
    \includegraphics[width=0.32\linewidth]{figures/sphere_side_r0.3.png     }
    \includegraphics[width=0.32\linewidth]{figures/sphere_quarter_r0.3.png  }
    \includegraphics[width=0.32\linewidth]{figures/sphere_front_r0.3.png    }
  \caption{Comparison of our retroreflector model (top) obtained by an almost trivial modification of the equivalent roughness GGX microfacet model (bottom). The lighting varies (left to right) from side-on, quarter-on, and straight-on, exhibiting the strong retro-reflective peak.
   \vspace{-0.5cm}
  \label{fig:teaser}}
}

\maketitle
\thispagestyle{firstpagestyle}

\begin{abstract}
  \small
  We introduce the ``Minimal Retroreflective Microfacet'' (MRM) model, which provides a simple scheme for modifying a pre-existing microfacet BRDF implementation to produce a visually plausible, energy-conserving retroreflective result.
  \end{abstract}

\section{Introduction}

Rendering of retro-reflective materials is useful in a variety of contexts. A number of CG models have been proposed. For practical purposes in visual effects, we are interested in a model which is a) visually plausible at least, b) provably energy-conserving, c) efficient and easy to implement, ideally a small modification to well-understood microfacet models. We present here a model based on a the previously published back-vector formulation~\cite{BelcourBackvector} which meets are these requirements. It is so simple a modification to a regular microfacet model, that we `Minimal Retroreflective Microfacet'' (MRM) model which achieves a plausible retro-reflective result.

In this document, we detail the correct usage and derivation of this retro-reflective BRDF model within the microfacet framework~\cite{WalterMicrofacet,HeitzMicrofacet}. We first recall some basic principles from microfacets theory (Section~\ref{sec:microfacets}) and show how to change it to account for retro-reflective microfacets (Section~\ref{sec:backvector}). We then detail how to implement this in practice (Section~\ref{sec:implementation}). Finally, we discuss how retro-reflection can occur at the microfacet level (Section~\ref{sec:plausibility}).

\section{Microfacet BRDF Models}
\label{sec:microfacets}

\begin{figure}
  \begin{center}
    \begin{tabular} {|l|l|}
      \hline
      $\vecv$ & normalized vector to viewer \\
      \hline
      $\vecl$ & normalized vector to light \\
      \hline
      $\vecn$ & surface normal \\
      \hline
      $\mathbf{t_1}, \mathbf{t_2}$ & tangent and bitangent (forming an orthonormal coordinate frame with the normal) \\
      \hline
      $\vech$ & half vector, $\vech = \vech(\vecv, \vecl) = \frac{\vecv + \vecl}{\lVert \vecv + \vecl \rVert}$ \\
      \hline
      $\vdot{\mathbf{x}}{\mathbf{y}}$ & dot product of $\mathbf{x}$ and $\mathbf{y}$ \\
      \hline
      $\text{reflect}(\mathbf{x}, \mathbf{m})$ & reflection of vector $\mathbf{x}$ on surface with normal $\mathbf{m}$, i.e. $\text{reflect}(\mathbf{x}, \mathbf{m}) = -\mathbf{x} + 2 \vdot{\mathbf{x}}{\mathbf{m}} \mathbf{m}$ \\
      \hline
      $\Omega$ & hemisphere of directions around the normal \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Notations used.}
  \label{fig:notation}
\end{figure}

Using the notations from figure \ref{fig:notation}, a microfacet BRDF \cite{WalterMicrofacet, HeitzMicrofacet} takes the form (\citet{WalterMicrofacet} Equation (20))
\begin{equation}
  f(\vecv, \vecl) = \frac{D(\vech) \, G_{2}(\vecv,\vecl) \, F(\vech, \vecv)}{4 \vdot{\vecv}{\vecn} \vdot{\vecl}{\vecn}}
  \label{eq:microfacet_model}
\end{equation}
where $D$ is the distribution of microfacets, normalized to fulfill $\int_\Omega D(\vech) \vdot{\vecn}{\vech} d\vech = 1$, $G_{2}$ is the shadowing-masking function, and $F$ is the Fresnel term. The half-vector $\vech$ is used as the \textit{selector} for microfacets reflecting light from incident direction $\vecl$ to outgoing direction $\vecv$ (\textit{i.e.} only microfacet with normals aligned with the half-vector will reflect light). In Section~4.1 of their work, Walter et al.~\cite{WalterMicrofacet} detail the effect of using the half vector as the microfacet selector and obtain Equation~\ref{eq:microfacet_model}.

In this work, we show that we can use the back vector~\cite{BelcourBackvector} used to model retro-reflection as a microfacet selector. Before detailing the impact of such a change, we review some properties of microfacet models.

\paragraph*{Shadowing-Masking.}
The shadowing-masking function combines the visibility masking function $G_1(\vecv, \vecl)$ for view direction and
$G_1(\vecl, \vecv)$ for light direction:
\begin{equation}
G_{2}(\vecv, \vecl) = G_{2}\left(G_1(\vecv, \vecl), G_1(\vecl, \vecv) \right)
\end{equation}
Mathematically, the BRDF is plausible if $G_{2}$ is symmetric w.r.t. to exchanging $\vecv$ and $\vecl$, fulfills
$G_{2}(\vecv, \vecl) \leq G_1(\vecv, \vecl)$, and if $G_1$ further establishes the correct projected area of visible micro-surfaces \cite{HeitzMicrofacet}
\begin{equation}\label{eq:visible}
  \vdot{\vecv}{\vecn} = \int_{\lbrace\vech \in \Omega: \vdot{\vecv}{\vech} \geq 0\rbrace} D(\vech) G_1(\vecv, \text{reflect}(\vecv, \vech)) \vdot{\vecv}{\vech} d\vech.
\end{equation}
Choices for $G_1$ with this property are the Smith masking function
\begin{equation}
  G_1(\vecv, \vecl) = G_{1,\text{Smith}}(\vecv) = \frac{\vdot{\vecv}{\vecn}}{\int_{\lbrace\vech \in \Omega: \vdot{\vecv}{\vech} \geq 0\rbrace} D(\vech) \vdot{\vecv}{\vech} d\vech},
\end{equation}
where analytic expressions are available for Beckmann and GGX distributions, and the v-cavity masking function
\begin{equation}
  G_1(\vecv, \vecl) = G_{1,\text{vc}}(\vdot{\vecv}{\vecn},\vdot{\vecn}{\vech},\vdot{\vecv}{\vech}) =
  \min\left\lbrace\frac{2\vdot{\vecv}{\vecn}\vdot{\vecn}{\vech}}{\vdot{\vecv}{\vech}}, 1\right\rbrace,
\end{equation}
which is generally applicable for distributions with symmetry around the normal.

\section{Back-vector Modification}
\label{sec:backvector}

If instead of half-vector $\vech$, we use the back-vector $\vecb$~\cite{BelcourBackvector} defined as
\begin{equation}
  \vecb(\vecv, \vecl) = \vech(\vecvv, \vecl) = \frac{\vecvv + \vecl}{\lVert \vecvv + \vecl \rVert}, \text{ with } \vecvv = \text{reflect}(\vecv, \vecn),
\end{equation}
to select the reflecting microfacet, we are to re-derive the microfacet model.

\paragraph*{Jacobian of Back-Vector.}
The first step is to write the Jacobian of the change of variable from the back-vector to the light vector $\vecl$~(Equation~(11) and~(14) of \citet{WalterMicrofacet}). Fortunately, this jacobian has the same form as the half-vector one:
\begin{equation}
\left\lVert \dfrac{\partial \omega_{\vecb}}{\partial \omega_{\vecl}} \right\rVert = \left\lVert \dfrac{\partial \omega_{\vech(\vecvv, \vecl)}}{\partial \omega_{\vecl}} \right\rVert = \dfrac{1}{4 \left| \vecl \cdot \vech(\vecvv, \vecl) \right|} = \dfrac{1}{4 \left| \vecl \cdot \vecb \right|}
\end{equation}

\paragraph*{Microfacet reflection term.}
We do not know for sure how the retro-reflective microfacet interacts with incident light. However, we have experimental evidence~\cite{BelcourBackvector} that it behaves similarly to a Fresnel term. We opted to reuse the Fresnel as well in the $(\vecvv, \vecl)$ configuration. As such, we update the formulation of $\rho(\vecv, \vecm)$~(Equation (11) of \citet{WalterMicrofacet}) to use the reflected view vector instead. It follows that the reflection microsurface BRDF~(Equation (15) of \citet{WalterMicrofacet}) becomes
\begin{equation}
  f_r^m(\vecv, \vecl, \vecm) = F(\vecvv, \vecm) \dfrac{\delta(\vecb, \vecm) }{4 \left| \vecvv \cdot \vecb \right|^2}.
\end{equation}
We used the fact that $\left| \vecl \cdot \vecb \right| = \left| \vecvv \cdot \vecb \right|$.

\paragraph*{Shadowing \& Masking.} \todo{Laurent: I think we could extract the shadowing from Matthias derivation here. The other way to justify the derivation of the full model is to highlight that Smith's shadowing/masking does not depend on the microfacet (appart from the sideness). Hence, whatever the microfacet selector (as long as the sideness matches), the shadowing/masking is the same. Since $\vecv$ and $\vecvv$ share the same slope, we can exchange them in the equation.}

\paragraph*{Final form.}
\begin{equation}
  f_R(\vecv, \vecl) = \frac{D(\vecb) \, G_{2}(\vecvv,\vecl) \, F(\vecb, \vecvv)}{4 \vdot{\vecvv}{\vecn} \vdot{\vecl}{\vecn}}
  \label{eq:retro_microfacet_model}
\end{equation}

\section{Plausibility of the Back-vector Modification}

\label{sec:plausibility}

In analogy to $\vecvv$ we let $\vecll := \text{reflect}(\vecl, \vecn)$.
First we observe
\begin{equation}\label{eq:nk}
  \begin{split}
    \vdot{\vecvv}{\vecn} &= \vdot{\vecv}{\vecn} \text{ and}\\
    \vdot{\vecl}{\vecn} &= \vdot{\vecll}{\vecn}.
  \end{split}
\end{equation}
For the back-vector we show $\vech(\vecvv, \vecl) = \text{reflect}\left(\vech(\vecll, \vecv), \vecn\right)$, as
\begin{equation}
  \begin{split}
  \vecvv + \vecl &=
  \left(-\vecv + 2 \vdot{\vecv}{\vecn} \vecn \right) + \vecl \\
  &= \left(-\vecv + 2 \vdot{\vecv}{\vecn} \vecn \right) + \left(- \vecll + 2 \vdot{\vecll}{\vecn} \vecn \right)\\
  &= -(\vecll + \vecv) + 2 \vdot{(\vecll + \vecv)}{\vecn} \vecn =
  \text{reflect}(\vecll + \vecv, \vecn)
  \end{split}
\end{equation}
and therefore $\lVert \vecvv + \vecl \rVert = \lVert \vecll + \vecv \rVert$ as well.
From that we can conclude
\begin{equation}\label{eq:nh}
  \begin{split}
    \vdot{\vecn}{\vech(\vecvv, \vecl)} &=
    \vdot{\vecn}{\vech(\vecll, \vecv)}\\
    \vdot{\mathbf{t_1}}{\vech(\vecvv, \vecl)} &=
    -\vdot{\mathbf{t_1}}{\vech(\vecll, \vecv)}\\
    \vdot{\mathbf{t_2}}{\vech(\vecvv, \vecl)} &=
    -\vdot{\mathbf{t_2}}{\vech(\vecll, \vecv)}.\\
    \end{split}
\end{equation}
As anisotropic Phong, Beckmann, and GGX distributions are reflection-symmetric around the normal, i.e. they take the form $D(\vech) = D\left(\vdot{\vecn}{\vech}, \lvert \vdot{\mathbf{t_1}}{\vech} \rvert, \lvert \vdot{\mathbf{t_2}}{\vech} \rvert\right)$, we can thus infer that using them with the back-vector obeys symmetry.
Further, the reflection symmetry of $D$ along with equation \eqref{eq:nk} gives
\begin{equation}
  \begin{split}
  G_{1,\text{Smith}}(\vecv) &=
  \frac{\vdot{\vecv}{\vecn}}{\int_{\lbrace\vech \in \Omega: \vdot{\vecv}{\vech} \geq 0\rbrace} D(\vech) \vdot{\vecv}{\vech} d\vech} \\
  &= \frac{\vdot{\vecvv}{\vecn}}{\int_{\lbrace\vech \in \Omega: \vdot{\vecvv}{\vech} \geq 0\rbrace} D(\vech) \vdot{\vecvv}{\vech} d\vech} =
  G_{1,\text{Smith}}(\vecvv)
  \end{split}
\end{equation}
for Smith-masking. Next we show
\begin{equation}
  \vdot{\vecvv}{\vecl} = -\vdot{\vecv}{\vecl} + 2 \vdot{\vecv}{\vecn}\vdot{\vecl}{\vecn}
  = \vdot{\vecv}{-\vecl + 2 \vdot{\vecl}{\vecn}\vecn} = \vdot{\vecv}{\vecll}
\end{equation}
and therefore
\begin{equation}\label{eq:kh}
  \vdot{\vecvv}{\vech(\vecvv, \vecl)} =
  \frac{1 + \vdot{\vecl}{\vecvv}}{\lVert \vecvv + \vecl \rVert} =
  \frac{1 + \vdot{\vecll}{\vecv}}{\lVert \vecll + \vecv \rVert} =
  \vdot{\vecll}{\vech(\vecll,\vecv)}.
\end{equation}
Using this along with equations \eqref{eq:nh} and \eqref{eq:nk} we get
\begin{equation}
  \begin{split}
  G_1(\vecvv, \vecl) &=
  G_{1, \text{vc}}\left( \vdot{\vecvv}{\vecn}, \vdot{\vecn}{\vech(\vecvv, \vecl)}, \vdot{\vecvv}{\vech(\vecvv, \vecl)} \right)\\
  &=  G_{1, \text{vc}}\left( \vdot{\vecv}{\vecn}, \vdot{\vecn}{\vech(\vecll, \vecv)}, \vdot{\vecll}{\vech(\vecll, \vecv)} \right) \\
  &=  G_{1, \text{vc}}\left( \vdot{\vecv}{\vecn}, \vdot{\vecn}{\vech(\vecv, \vecll)}, \vdot{\vecll}{\vech(\vecv, \vecll)} \right) \\
  &= G_1(\vecv, \vecll)
  \end{split}
\end{equation}
and similarly $G_1(\vecl, \vecvv) = G_1(\vecll, \vecv)$ for the v-cavity masking function.
In summary, we can conclude the symmetry of the BRDF
\begin{equation}
  \begin{split}
  f_{\text{retro}}(\vecv, \vecl) =
  f(\vecvv, \vecl) &=
  \frac{D(\vech(\vecvv, \vecl)) G_{2}(G_1(\vecvv, \vecl), G_1(\vecl, \vecvv))}{4 \vdot{\vecvv}{\vecn} \vdot{\vecl}{\vecn} }\\
  &=
  \frac{D(\vech(\vecll, \vecv)) G_{2}(G_1(\vecv, \vecll), G_1(\vecll, \vecv))}{4 \vdot{\vecv}{\vecn} \vdot{\vecll}{\vecn} } =
  f(\vecll, \vecv) =
  f_{\text{retro}}(\vecl, \vecv).
  \end{split}
\end{equation}
For the albedo we simply have
\begin{equation}
  \rho_{\text{retro}}(\vecv) =
  \int_\Omega f_{\text{retro}}(\vecv, \vecl) \vdot{\vecl}{\vecn} d\vecl =
  \int_\Omega f(\vecvv, \vecl) \vdot{\vecl}{\vecn} d\vecl = \rho(\vecvv)
\end{equation}
i.e. we get the albedo of the regular microfacet BRDF for the reflected direction.
Which, using equation \eqref{eq:visible} and $\frac{d\vech(\vecvv, \vecl)}{d\vecl} = \frac{1}{4 \vdot{\vecl}{\vech(\vecvv, \vecl)}}= \frac{1}{4 \vdot{\vecvv}{\vech(\vecvv, \vecl)}}$ \cite{WalterMicrofacet}, can be shown to fulfill energy conservation
\begin{equation}
  \begin{split}
  \rho(\vecvv) &=
  \int_\Omega \frac{D(\vech(\vecvv, \vecl)) G_{2}(\vecvv,\vecl)}{4 \vdot{\vecvv}{\vecn} \vdot{\vecl}{\vecn}}\vdot{\vecl}{\vecn} d\vecl\\
  &\leq
  \int_{\lbrace\vech \in \Omega: \vdot{\vecvv}{\vech} \geq 0\rbrace} \frac{D(\vech) G_1(\vecvv,\text{reflect}(\vecvv, \vech))}{\vdot{\vecvv}{\vecn}}\vdot{\vecvv}{\vech} d\vech
  = 1.
  \end{split}
\end{equation}

\section{Implementation Notes}
\label{sec:implementation}

Given an implementation of a regular microfacet BRDF, extending it to retro-reflection is straightforward:

\begin{itemize}
\item
  Evaluation merely needs to replace $\vecv$ with $\vecvv$ upfront.
\item
  Similarly, importance sampling of $\vecl$ given $\vecv$ can be realized by replacing $\vecv$ with $\vecvv$ upfront and then importance sampling the regular microfacet BRDF.
  This may include low variance sampling using the domain of visible microfacets \cite{HeitzIS}.
\item
  As the albedos of standard BRDF and retro-reflective BRDF are essentially identical, compensating for energy loss in the sense of \cite{KelemenBRDF} can be realized using the same data tables.
\item Pseudo-code is provided in Listing~\ref{lst:implementation}.
\end{itemize}

\noindent\begin{minipage}[tb]{\linewidth}
\begin{lstlisting}[
    language=GLSL,
    caption=Pseudo code to implement the retro-reflective microfacet model.,
    label=lst:implementation,
    nolol=true,
    frame=trBL
    ]
vec3 brdf_retro(vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y)
{
    vec3 Vp = -reflect(V,N); // jp - is this wrong? Why the minus sign

    // The following could all be replaced with:
    // We could give the simplified form of brdf_ggx, but not essential.
    return brdf_ggx(L, Vp, N, X, Y);

    /*
    float NdotL = dot(N, L);
    float NdotV = dot(N, Vp);
    if (NdotL < 0 || NdotV < 0) return vec3(0);

    vec3 B = normalize(L+Vp);
    float NdotH = dot(N, B);
    vec3 wB = vec3(dot(B,X),  dot(B,Y),  dot(B,N));
    vec3 wL = vec3(dot(L,X),  dot(L,Y),  dot(L,N));
    vec3 wV = vec3(dot(Vp,X), dot(Vp,Y), dot(Vp,N));

    float D = D_GGX(wB, ax, ay);
    float G = G2_GGX(wV, wL, ax, ay);

    float c = dot(L, B);
    float F = schlick(f0, c); // I don't think we need to give the form of the Fresnel

    float val = Ks * D * G * F / (4 * NdotL * NdotV);
    return vec3(val);
    */
}
\end{lstlisting}
\end{minipage}

\section{Implementation Notes}

Given an implementation of a regular microfacet BRDF, extending it to retro-reflection is straightforward:

\begin{itemize}
\item
  Evaluation merely needs to replace $\vecv$ with $\vecvv$ upfront.
\item
  Similarly, importance sampling of $\vecl$ given $\vecv$ can be realized by replacing $\vecv$ with $\vecvv$ upfront and then importance sampling the regular microfacet BRDF.
  This may include low variance sampling using the domain of visible microfacets \cite{HeitzIS}.
\item
  As the albedos of standard BRDF and retro-reflective BRDF are essentially identical, compensating for energy loss in the sense of \cite{KelemenBRDF} can be realized using the same data tables.
\end{itemize}



\bibliographystyle{jcgt}
\bibliography{citations}

\section*{Author Contact Information}

\hspace{-2mm}\begin{tabular}{p{0.48\textwidth}p{0.48\textwidth}}
Matthias Raab \newline
\href{mailto:matthias.raab@gmail.com}{matthias.raab@gmail.com} \newline
&
Laurent Belcour \newline
\href{mailto:laurent.belcour@gmail.com}{laurent.belcour@gmail.com} \\
Frankie Liu \newline
\href{mailto:frankie.liu@gmail.com}{frankie.liu@gmail.com} \newline
&
Jamie Portsmouth \newline
\href{mailto:jamports@mac.com}{jamports@mac.com} \newline
\end{tabular}


\end{document}


